<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Bandersnatch</title>

<style>
body { margin: auto; text-align: center; margin-top: 50px; }
#graph { margin: auto; height: 50%; width: 50%; }
video { width: 100%; height: 100%; }
.controls { margin: auto; width: 100%; }
ul { font: 20px sans-serif; display: flex; align-items: stretch; justify-content: space-around; width: 100%; margin: 10px 0 10px 0; padding: 0; }
li { display: block; flex: 0 1 auto; list-style-type: none; }
#progress { background-color: grey; width: 0%; height: 5px; margin: auto; margin-top: 0px; }
</style>

<!-- bandersnatch object https://gist.githubusercontent.com/jonluca/860f3f445e7d84054822276fd058301a (add bandersnatch= line on top) -->
<script src="bandersnatch.js"></script>

<!-- SegmentMap object https://github.com/jolbol1/Bandersnatch/blob/master/SegmentMap.json (add SegmentMap= line on top) -->
<script src="SegmentMap.js"></script>

<script>

var segmentMap = SegmentMap;
var bv = bandersnatch.videos['80988062'].interactiveVideoMoments.value;
var choicePoints = bv.choicePointNavigatorMetadata.choicePointsMetadata.choicePoints;
var momentsBySegment = bv.momentsBySegment;
var segmentGroups = bv.segmentGroups;
var captions = {};
var currentSegment;
var currentMoment;
var nextSegment = null;
var momentSelected = null;
var persistentState = bv.stateHistory;
var globalChoices = {};


function generateJs(cond) {
	if (cond[0] == 'persistentState') {
		return '!!persistentState["' + cond[1] + '"]';
	} else if (cond[0] == 'not') {
		return '!(' + generateJs(cond[1]) + ')';
	} else if (cond[0] == 'and') {
		var conds = [];
		for (var i = 1; i < cond.length; i++) {
			conds.push('(' + generateJs(cond[i]) + ')');
		}
		return '(' + conds.join(' && ') + ')';
	} else if (cond[0] == 'or') {
		var conds = [];
		for (var i = 1; i < cond.length; i++) {
			conds.push('(' + generateJs(cond[i]) + ')');
		}
		return '(' + conds.join(' || ') + ')';
	} else {
		console.log('unsupported condition!', cond);
		return 'true';
	}
}

function checkPrecondition(segmentId) {
	let precondition = bv.preconditions[segmentId];

	if (precondition) {
		let cond = generateJs(precondition);
		let match = eval(cond);

		console.log(cond, '==', match);

		return match;
	}

	return true;
}

function findSegment(id) {
	if (id.startsWith('nsg-')) {
		id = id.substr(4);
	}
	if (SegmentMap.segments[id]) {
		// check precondition
		return id;
	}

	if (segmentGroups[id]) {
		for(v of segmentGroups[id]) {
			if (v.segmentGroup) {
				return findSegment(v.segmentGroup);
			} else if (v.segment) {
				// check precondition
				return v.segment;
			} else {
				if (checkPrecondition(v))
					return v;
			}
		}
	}
	return id;
}

function getChoiceMs(choiceId) {
	var segmentId = findSegment(choiceId);
	return getSegmentMs(segmentId);
}

function getSegmentId(ms) {
	for(const [k, v] of Object.entries(SegmentMap.segments)) {
		if (ms>=v.startTimeMs && ms<v.endTimeMs) {
			return k;
		}
	}
	return null;
}

function getSegmentMs(segmentId) {
	return segmentMap.segments[segmentId].startTimeMs;
}

function getMoment(ms) {
	for(const [k, v] of Object.entries(momentsBySegment)) {
		for(r of v) if (r.type=='scene:cs_bs') {
			if (ms>=r.startMs && ms<r.endMs) {
				return r;
			}
		}
	}
	return null;
}

function newList(id) {
	var ul = document.getElementById(id);
	while (ul.firstChild) {
		ul.removeChild(ul.firstChild);
	}
	return ul;
}

function addItem(ul, text, url) {
	var li = document.createElement("li");
	var a = document.createElement("a");
	a.textContent = text;
	a.setAttribute('href', url);
	li.appendChild(a);
	ul.appendChild(li);
}

function setNextSegment(segmentId, comment) {
	nextSegment = segmentId;
	var ul = newList("nextSegment");
	var caption = 'nextSegment: '+segmentId;
	addItem(ul, comment ? caption + ' ('+comment+')' : caption,
		'javascript:playSegment("'+segmentId+'")');
}

function addZones(segmentId) {
	var ul = newList("interactionZones");
	var caption = 'currentSegment('+ segmentId + ')';
	addItem(ul, caption, 'javascript:playSegment("'+segmentId+'")');

	var v = segmentMap.segments[segmentId];
	if (v && v.ui && v.ui.interactionZones) {
		var index = 0;
		for (z of v.ui.interactionZones) {
			var startMs = z[0];
			var stopMs = z[1];
			var caption = segmentId+' interactionZone ' + index;
			addItem(ul, caption, 'javascript:seek('+startMs+')');
			index++;
		}
	}

	var ul = newList("nextSegments");
	for (const [k, v] of Object.entries(segmentMap.segments[segmentId].next)) {
		var caption = captions[k] ? captions[k] : k;
		if (segmentMap.segments[segmentId].defaultNext==k) {
			caption = '['+caption+']';
			setNextSegment(k);
		}
		addItem(ul, caption, 'javascript:playSegment("'+k+'")');
	}
}

function addChoices(r) {
	var ul = newList("choices");
	document.getElementById("choiceCaption").innerHTML = '';
	if (!r) return;
	index = 0;

	for (x of r.choices) {
		console.log(x.id, 'choice saved');
		globalChoices[x.id] = x;

		var caption = r.defaultChoiceIndex==index ? '['+x.text+']' : x.text;
		addItem(ul, caption, 'javascript:choice("'+
			(x.segmentId ? x.segmentId : (x.sg ? x.sg : x.id))+'", "'+x.text+'", "'+x.id+'")');
		index++;
	}

	document.getElementById("choiceCaption").innerHTML = choicePoints[r.id].description;
}


function updateProgressBar(ms, r) {
	var p = 0;

	if (r && ms>r.startMs && ms<r.endMs) {
		p = 100 - Math.floor((ms - r.startMs) * 100 / (r.endMs - r.startMs));
	}

	document.getElementById("progress").style.width = p + '%';
}

var timerId = 0;

var switchFrom = null;
var switchTo = null;

function ontimeout(nextSegment) {
	console.log('ontimeout', nextSegment);
	if (switchFrom!=currentSegment || switchTo!=nextSegment)
		playSegment(nextSegment);
	switchFrom = currentSegment;
	switchTo = nextSegment;
}

function ontimeupdate() {
	var ms = document.getElementById("video").currentTime * 1000.0;

	var segmentId = getSegmentId(ms);

	// ontimeupdate resolution is about a second, better use timer
	clearTimeout(timerId);
	if (segmentId && nextSegment && nextSegment!=segmentId) {
		var timeLeft = SegmentMap.segments[segmentId].endTimeMs - ms;
		timerId = setTimeout(ontimeout, timeLeft, nextSegment);
	}

	if (currentSegment != segmentId) {
		console.log('ontimeupdate', currentSegment, segmentId);
		currentSegment = segmentId;
		addZones(segmentId);
		currentMoment = null;
		addChoices(0);
	}

	var r = getMoment(ms);
	if (r && momentSelected!=r.id) {
		updateProgressBar(ms, r);
		if (currentMoment!=r.id) {
			currentMoment = r.id;
			console.log('interaction', currentMoment);
			addChoices(r);
		}
	} else {
		currentMoment = null;
		addChoices(0);
		updateProgressBar(0);
	}
}

function onload() {
	document.getElementById("video").ontimeupdate = ontimeupdate;

	document.onkeydown = function(evt) {
		var v = document.getElementById("video");
		if (evt.key=='ArrowLeft') {
			v.currentTime = v.currentTime - 1;
		}
		if (evt.key=='ArrowRight') {
			v.currentTime = v.currentTime + 1;
		}
	}

	if (location.hash) {
		var segmentId = location.hash.slice(1);
		playSegment(segmentId);
	}
}

function seek(ms) {
	momentSelected = null;
	document.getElementById("video").currentTime = ms / 1000.0;
}

function choice(choiceId, text, id) {
	var segmentId = findSegment(choiceId);
	console.log('choice', choiceId, 'nextSegment', segmentId);
	applyImpression(globalChoices[id]);
	setNextSegment(segmentId, text);
	momentSelected = choiceId;
	addChoices(0);
}

function applyImpression(obj) {
	if (!obj) {
		return;
	}

	impressionData = obj.impressionData;

	if (impressionData && impressionData.type == 'userState') {
		for (const [variable, value] of Object.entries(impressionData.data.persistent)) {
			console.log('persistentState set', variable, '=', value);
			persistentState[variable] = value;
		}
	}
}

function applyPlaybackImpression(segmentId) {
	let moments = momentsBySegment[segmentId];

	if (!moments) {
		console.log('warning - no moments');
		return;
	}

	for (moment of moments) {
		if (moment.type != 'notification:playbackImpression') {
			continue;
		}

		applyImpression(moment);
	}
}

function playSegment(segmentId) {
	if (segmentId=="undefined")
		segmentId = '1A';
	console.log('playSegment', segmentId);
	applyPlaybackImpression(segmentId);
	location.hash = segmentId;
	document.title = 'Bandersnatch - Chapter ' + segmentId;
	document.getElementById("video").ontimeupdate = function() {};
	seek(getSegmentMs(segmentId));
	document.getElementById("video").ontimeupdate = ontimeupdate;
}


</script>
</head>
<body onload=onload()>
<div>
	<div id="graph">
		<video id="video" autoplay controls src="Black.Mirror.Bandersnatch.2018.720p.WEB-DL.x264.DUAL.mkv">
		</video>
		<div class="controls">
			<div id="choiceCaption"></div>
			<div id="progress"></div>
			<div class="buttons">
				<ul id="choices"></ul>
				<ul id="interactionZones"></ul>
				<ul id="nextSegments"></ul>
				<ul id="nextSegment"></ul>
			</div>
		</div>
	</div>
</div>
</body>
</html>